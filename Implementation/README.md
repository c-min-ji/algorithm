# Implementation(구현)

#### *머릿속에 있는 알고리즘을 소스코드로!*
<br>

## 예시 문제


#### [01-1. 상하좌우](./up_down_left_right.py)<br>
__*설명*__<br>
NxN 크기의 좌표에서 입력된 값에 따라 이동했을 때 도착 지점 좌표 리턴<br>
dx, dy 이용해서 풀이<br>
__*POINT*__ <br>
좌표 밖을 나가지 않는 것<br>

|시간 복잡도|
|:--:|
|O(N): 이동 횟수에 비례|

--------


#### [01-2. 시각](./time.py)<br>
__*설명*__<br>
주어진 시각 속에 3이 포함되는 경우의 수를 찾아라<br><br>
__*POINT*__ <br>
시, 분, 초 마다 for문을 돌려 str로 바꿔서 카운팅<br>

-----

#### [02. 왕실의 나이트](./knight.py)<br>
__*설명*__<br>
8x8 체스판에서 다음과 같은 규칙으로만 이동할 수 있다. 처음 좌표가 주어질 때, 움직일 수 있는 경우의 수를 구하라<br>
>__*규칙*__ <br> 1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기<br> 2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기
<br>

__*POINT*__ <br>
상하좌우 문제와 유사. 범위를 벗어나지 않게 주의<br>

-----

#### [03. 게임 개발](./game_dev.py)<br>
__*설명*__<br>
NxM 크기의 지도에서 캐릭터가 방문한 칸의 개수를 구하여라<br>
>__*매뉴얼*__ <br> 1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다. <br> 2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로만 회전을 수행하고 1단계로 돌아간다. <br> 3. 만약 네 방향 모두 이미 기본 칸이거나 바다로 되어 있는 칸인 경우레는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다. 
<br>

__*POINT*__ <br>
dx, dy라는 별도의 리스트를 만들어서 방향을 정함<br>

-----
#### 참고 문제<br>

> [비밀지도](https://programmers.co.kr/learn/courses/30/lessons/17681)<br>
