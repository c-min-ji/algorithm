# 기타 그래프 이론

### 서로소 집합 자료구조
__*서로소 집합*__: 공통 원소가 없는 두 집합<br><br>

__*알고리즘(트리 이용)*__<br>
1. union(합집합) 연산을 확인해 서로 연결된 노드 a,b를 확인한다. <br>
2. a, b의 루트 노드를 찾고 a의 루트 노드를 b의 루트 노드의 부모 노드로 설정한다. (두 루트 노드 중 숫자가 작은 걸 부모 노드로!)

 * [소스코드](./basic.py)

----

### 경로 압축 기법
```python
def find_parent(parent, x):
  if parent[x] != x:
    parent[x] = find_parent(parent, parent[x]) #재귀 호출
  return parent[x] #부모 테이블 값 갱신 기존에는 그냥 x 리턴했음
```

 * 경로 압축 기법을 사용하면 시간 복잡도 개선 가능

----

### 서로소 집합 알고리즘 시간 복잡도
= O(V + M(1+log(2-M/V)V))
<br><br>

----
### 서로소 집합을 이용항 사이클 판별
무방향 그래프의 사이클을 판별할 때 사용할 수 있다.<br>
*cf.* 방향 그래프에서의 사이클 여부는 DFS를 이용해 판별가능<br> 
<br>
__*알고리즘*__<br>
1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
2. 루트 노드가 서로 다르면 두 노드에 대해 union 연산을 수행한다.
3. 루트 노드가 서로 같다면 사이클이 발생한 것이다.
<br>

----

### 신장 트리
하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프(어딘가 끊겨있는 거임. 하지만 다 연결을 되어있어야함 cycle없는 것)<br>

 * __[크루스칼 알고리즘](./kruskal.py)__<br>신장 트리중에서 최소 비용으로 만들 수 있는 알고리즘인 '최소 신장 트리 알고리즘' 중에 대표적인 알고리즘<br>__*알고리즘*__<br> 1. 간선 데이터를 비용에 따라 오름차순 정렬<br> 2. 간선을 확인하며 사이클을 발생시키지 않으면 최소 신장 트리에 포함

<br>

----

### [위상 정렬](./topology.py)
방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'<br>
 * 진입 차수<br>특정한 노드로 들어오는 간선의 개수<br><br>

__*알고리즘*__<br>
1. 진입 차수가 0인 노드를 큐에 넣음
2. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거
3. 새롭게 진입 차수가 0이 된 노드를 큐에 넣음

----

### 예시 문제
1. __[팀 결성](./team.py)__<br>
__*문제 설명*__<br>
'팀 합치기 연산' = 0 a b <br>
'같은 팀 여부 확인' = 1 a b <br>
같은 팀 여부 확인 때 다른 팀이면 No 출력 같은 팀이면 Yes 출력

2. __[도시 분할 계획](./city.py)__<br>
__*문제 설명*__<br>
마을 이장은 마을에 길이 너무 많다고 생각해 마을을 분할하면서 그 각 마을안에서는 모든 집들이 연결되어있게 하며 유지비가 제일 적게 들게 만들고싶다!<br>
전체 그래프에서 2개의 최소 신장 트리 만든다.<br>

3. __[커리큘럼](./curri.py)__<br>
__*문제 설명*__<br>
듣고자 하는 n개의 강의 정보가 주어질 때, n개의 강의를 수강하는 데까지 걸리는 최소 시간을 구하시오.<br>
위상 정렬 알고리즘 사용
