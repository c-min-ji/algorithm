## 다이나믹 프로그래밍(Dynamic Programming)
연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘
<br>
동적 계획법이라고도 표현<br>
> __DP의 조건__ <br> 1. 큰 문제를 작은 문제로 나눌 수 있다. <br> 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

### 대표적인 예시
피보나치 수열_등차 수열<br>
점화식의 가장 대표적인 문제이기도 함<br>
> __피보나치 수열의 전개 방식__ <br> 1, 1, 2, 3, 5, 8, 13...
#### 피보나치 수열의 점화식
```
a[n] = a[n-1] + a[n-2]
a[0] = 1, a[1] = 1
```

#### 가장 기본적인 피보나치 수열 코드(재귀 함수 이용)
```python
def fibo(x):
  if x == 1 or x == 2:
    return 1
  else:
    return fibo(x-1) + fibo(x-2)
```

> __단점__ <br> 수행 시간이 O(2^N)이 됨 <br> 동일한 함수가 한 번 호출될 때마다 똑같이 호출되어 수행 시간이 급격히 늘어남<br>

#### DP의 조건을 만족하는 피보나치 수열
 * __메모제이션 기법 사용 - 탑다운 방식(Top-Down)__<br>메모제이션은 DP 구현 방법 중 하나로 한 번 구현한 결과를 메모리 공간에 메모하고 다시 호출하면 메모한 결과를 그대로 가져온다.<br>캐싱(caching)이라고도 한다.
 * __구현 방식__ <br> 한 번 구한 정보를 리스트에 저장하고 재귀적으로 수행하다가 같은 정보가 필요할 때 리스트에 저장된 값을 가져온다.
```python
d = [0]*100 # 리스트를 초기화 해줌

def fibo(x):
  if x == 1 or x == 2: # x가 1이나 2이면 1 값을 돌려줌
    return 1
  if d[x] != 0: # d[x]가 초기값이 아니면 안에 들어 있는 값을 돌려줌
    return d[x]
  d[x] = fibo(x-1) + fibo(x-2) # d[x]에 값을 넣어주는 구간
  return d[x]
```
<br>

 * __반복문 사용 - 보텀업 방식(Bottom-Up)__<br>단순 반복문을 사용하여 작은 문제부터 차근차근 답을 도출한다. DP의 가장 전형적인 
 * __구현 방식__ <br> 단순 반복문 사용
```python
d = [0]*100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
  d[i] = d[i-1] + d[i-2]
 
print(d[n])
```

### 연습 문제
[1. 1로 만들기](./make_one.py)
> __설명__<br> 다음과 같은 4가지 연산을 최소한으로 이용해 주어진 X를 1로 만들어라
> ```
> 1. X가 5로 나누어떨어지면, 5로 나눈다.
> 2. X가 3으로 나누어떨어지면, 3으로 나눈다.
> 3. X가 2로 나누어떨어지면, 2로 나눈다.
> 4. X에서 1을 뺀다.
> ```

<br>

[2. 개미전사](./ant.py)
> __설명__<br> 식량 창고에서 가장 많이 얻어 올 수 있는 식량의 양을 구하여라. 단, 인접한 식량 창고에서는 못가져온다.


<br>

[3. 바닥 공사](./floor.py)
> __설명__<br> Nx2 크기인 바닥이 있다. 이를 2x1, 1x2, 2x2 덮개로 덮을 수 있는 경우의 수를 구하시오.

<br>

[4. 효율적인 화폐 구성](./money.py)
