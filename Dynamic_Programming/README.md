## 다이나믹 프로그래밍(Dynamic Programming)
연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘
<br>
동적 계획법이라고도 표현<br>
> __DP의 조건__ <br> 1. 큰 문제를 작은 문제로 나눌 수 있다. <br> 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

### 대표적인 예시
피보나치 수열_등차 수열<br>
점화식의 가장 대표적인 문제이기도 함<br>
> __피보나치 수열의 전개 방식__ <br> 1, 1, 2, 3, 5, 8, 13...
#### 피보나치 수열의 점화식
```
a[n] = a[n-1] + a[n-2]
a[0] = 1, a[1] = 1
```

#### 가장 기본적인 피보나치 수열 코드(재귀 함수 이용)
```python
def fibo(x):
  if x == 1 or x == 2:
    return 1
  else:
    return fibo(x-1) + fibo(x-2)
```

> __단점__ <br> 수행 시간이 O(2^N)이 됨 <br> 동일한 함수가 한 번 호출될 때마다 똑같이 호출되어 수행 시간이 급격히 늘어남<br>

#### DP의 조건을 만족하는 피보나치 수열
 * __메모제이션 기법 사용__<br>메모제이션은 DP 구현 방법 중 하나로 한 번 구현한 결과를 메모리 공간에 메모하고 다시 호출하면 메모한 결과를 그대로 가져온다.<br>캐싱(caching)이라고도 한다.
 * __구현 방식__ <br> 한 번 구한 정보를 리스트에 저장하고 재귀적으로 수행하다가 같은 정보가 필요할 때 리스트에 저장된 값을 가져온다.
```python
d = [0]*100 # 리스트를 초기화 해줌

def fibo(x):
  if x == 1 or x == 2: # x가 1이나 2이면 1 값을 돌려줌
    return 1
  if d[x] != 0: # d[x]가 초기값이 아니면 안에 들어 있는 값을 돌려줌
    return d[x]
  d[x] = fibo(x-1) + fibo(x-2) # d[x]에 값을 넣어주는 구간
  return d[x]
```
